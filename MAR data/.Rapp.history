ggplot(data=tot.prod,aes(x=year,y=production.g.m2,fill=lakeID))+geom_bar(stat='identity',position=position_dodge())+scale_fill_manual(values=c('EL'='brown','WL'='blue'))+ylab(expression(paste('production (g m'^-2,' yr'^-1,')')))
ggplot(data=tot.prod,aes(x=year,y=production.g.m2.yr,fill=lakeID))+geom_bar(stat='identity',position=position_dodge())+scale_fill_manual(values=c('EL'='brown','WL'='blue'))+ylab(expression(paste('production (g m'^-2,' yr'^-1,')')))
temp<-mean(temp.past$temp[temp.past$year==2013 & temp.past$lakeID=='EL'])
temp
temp<-mean(temp.past$temp[temp.past$year==2013 & temp.past$lakeID=='WL'])
temp
tapply(lengths.past$mass[lengths.past$year==2013 & lengths.past$lakeID=='EL'],lengths.past$taxa[lengths.past$year==2013 & lengths.past$lakeID=='EL'],max,na.rm=T)/1000
tapply(lengths.past$mass[lengths.past$year==2013 & lengths.past$lakeID=='WL'],lengths.past$taxa[lengths.past$year==2013 & lengths.past$lakeID=='WL'],max,na.rm=T)/1000
#Script that runs MAR (multivariate autoregressive) model for Long Lake zooplankton from 2011-2014 (browning experiment)#
#Objective: to determine potential drivers of zooplankton biomass across the experiments in the two basins#
#Using effect sizes of a model of hypothesized drivers, rather than running exhaustive search of potential drivers#
#Patrick Kelly 13 January 2014#
#
#load zooplankton data#
setwd('~/Documents/Notre Dame/long lake data/MAR data')#
#
zoops<-read.csv('zoopDataMatrix2011-2014.csv')#
#
#load covariate data#
cov.mat<-read.csv('covariateData2011-2014.csv')#
#
#combine the two to sort#
tot.data<-cbind(zoops,cov.mat[2:ncol(cov.mat)])#
#
#sort by date#
tot.data<-tot.data[order(tot.data$lakeID,tot.data$dateSample),]#
#make lake-year ID#
tot.data$year<-format(as.Date(tot.data$dateSample,'%Y-%m-%d'),'%Y')#
tot.data$lake.year<-paste(tot.data$lakeID,format(as.Date(tot.data$dateSample,'%Y-%m-%d'),'%Y'),sep='.')#
lake.year<-c(tot.data$lake.year[tot.data$lakeID=='EL'],tot.data$lake.year[tot.data$lakeID=='WL'])#
#
#remove NAs#
tot.data<-tot.data[!is.na(tot.data$cyclopoid.gm2),]#
tot.data<-tot.data[!is.na(tot.data$holhopedium.gm2),]#
#
#build a matrix of data with 3 taxa#
tsMat<-as.matrix(tot.data[,6:8],ncol=3)#
#
#make X and Y#
X=tsMat[1:nrow(tsMat)-1,] # this is Xt#
Y=tsMat[2:nrow(tsMat),] #this is Xt+1#
#
#make covariate matrix#
covMat<-as.matrix(tot.data[,9:14],ncol=6)#
covMat<-covMat[1:nrow(covMat)-1,]#
#
#remove transition year data points in both X, Y, and covariate data#
WLyearX<-tot.data$year[tot.data$lakeID=='WL'][1:length(tot.data$year[tot.data$lakeID=='WL'])-1]#
WLyearY<-tot.data$year[tot.data$lakeID=='WL'][2:length(tot.data$year[tot.data$lakeID=='WL'])]#
#
X<-X[WLyearX==WLyearY,]#
Y<-Y[WLyearX==WLyearY,]#
covMat<-covMat[WLyearX==WLyearY,]#
#
#make z-scored matrix to find effect sizes#
col.mean<-colMeans(covMat) #get means for columns#
col.sd<-apply(covMat,2,sd)#
#
z.covMat<-c()#
for(i in 1:nrow(covMat)){#
	x<-(covMat[i,]-col.mean)/col.sd#
	z.covMat<-rbind(z.covMat,x)#
}#
#
one<-rep(1,nrow(X)) #1 in the model#
#
Z<-cbind(one,X,z.covMat) #combining 1, X, u <---can change z.covMat to covMat if you don't want z-scored covariate matrix#
#
#estimate parameters using CLS#
D<-solve(t(Z)%*%Z)%*%t(Z)%*%Y
D
#calculate predicted #
predict<-Z%*%D#
#Q=length of time series#
#P=number of species#
#R=number of coviates#
#E=errors (predict-X)#
#varY=variance in Y=obs-mean#
#root mean squared error sd(E)#
#
Q<-nrow(X)#
P<-ncol(X)#
R<-0#
E<-predict-Y#
rmse<-sd(E)#
varY=matrix(c(Y[,1]-mean(Y[,1]),Y[,2]-mean(Y[,2]),Y[,3]-mean(Y[,3])),ncol=3)#
#
sigma<-t(E)%*%E/Q#
lnlike<--Q*(P/2)*log(2*pi)-(Q/2)*log(det(sigma))-Q*P/2#
#
#calculate total r2#
varMatrix<-t(varY)%*%varY/Q#
R2<-1-diag(sigma)/diag(varMatrix)
R2
#calculate r^2 based on dY's#
varDY=(Y-X)[-1,]#
DYhat=c()#
for(i in 2:nrow(predict)){#
	x=predict[i,]-predict[i-1,]#
	DYhat=rbind(DYhat,x)#
}#
#
E_D<-DYhat-varDY#
#
QD<-nrow(Y)#
varMatrix_D<-t(varDY)%*%varDY/Q#
R2_D<-diag(sigma)/diag(varMatrix_D)
R2_D
mean(X)
sd(X)
X
col.mean<-colMeans(X)
col.mean
col.sd<-apply(X,2,sd)
col.sd
col.mean<-colMeans(X)#
col.sd<-apply(X,2,sd)#
#
z.X<-c()#
for(i in 1:nrow(X)){#
	x<-(X[i,]-col.mean)/col.sd#
	z.X<-rbind(z.X,x)#
}#
#
col.mean<-colMeans(Y)#
col.sd<-apply(Y,2,sd)#
#
z.Y<-c()#
for(i in 1:nrow(X)){#
	x<-(Y[i,]-col.mean)/col.sd#
	z.Y<-rbind(z.Y,x)#
}
X
Y
one<-rep(1,nrow(X)) #1 in the model
Z<-cbind(one,z.X,z.covMat) #combining 1, X, u <---can change z.covMat to covMat if you don't want z-scored covariate matrix
Z
D<-solve(t(Z)%*%Z)%*%t(Z)%*%z.Y
D
round(D,digits=4)
setwd('~/Desktop')
round.D<-round(D,digits=4)
prod
tot.prod
tot.prod$production.g.m2.yr[tot.prod$lakeID=='EL']/tot.prod$production.g.m2.yr[tot.prod$lakeID=='WL']
D
getwd()
write.csv(D,'MARoutputTable.csv')
prod.ratio<-tot.prod$production.g.m2.yr[tot.prod$lakeID=='EL']/tot.prod$production.g.m2.yr[tot.prod$lakeID=='WL']
ratio.table<-data.frame(year=c(2011,2012,2013,2014),poduction.ratio.EL:WL=prod.ratio)
ratio.table<-data.frame(year=c(2011,2012,2013,2014),poduction.ratio.EL.WL=prod.ratio)
ratio.table
write.csv(ratio.table,'EL.WLratio.csv')
#calculate predicted #
predict<-Z%*%D#
#Q=length of time series#
#P=number of species#
#R=number of coviates#
#E=errors (predict-X)#
#varY=variance in Y=obs-mean#
#root mean squared error sd(E)#
#
Q<-nrow(X)#
P<-ncol(X)#
R<-0#
E<-predict-Y#
rmse<-sd(E)#
varY=matrix(c(Y[,1]-mean(Y[,1]),Y[,2]-mean(Y[,2]),Y[,3]-mean(Y[,3])),ncol=3)#
#
sigma<-t(E)%*%E/Q#
lnlike<--Q*(P/2)*log(2*pi)-(Q/2)*log(det(sigma))-Q*P/2#
#
#calculate total r2#
varMatrix<-t(varY)%*%varY/Q#
R2<-1-diag(sigma)/diag(varMatrix)#
#
#calculate r^2 based on dY's#
varDY=(Y-X)[-1,]#
DYhat=c()#
for(i in 2:nrow(predict)){#
	x=predict[i,]-predict[i-1,]#
	DYhat=rbind(DYhat,x)#
}#
#
E_D<-DYhat-varDY#
#
QD<-nrow(Y)#
varMatrix_D<-t(varDY)%*%varDY/Q#
R2_D<-diag(sigma)/diag(varMatrix_D)
R2
R2_D
head(z.covMat)
#calculate predicted #
predict<-Z%*%D#
#Q=length of time series#
#P=number of species#
#R=number of coviates#
#E=errors (predict-X)#
#varY=variance in Y=obs-mean#
#root mean squared error sd(E)#
#
Q<-nrow(X)#
P<-ncol(X)#
R<-ncol(z.covMat)#
E<-predict-Y#
rmse<-sd(E)#
varY=matrix(c(Y[,1]-mean(Y[,1]),Y[,2]-mean(Y[,2]),Y[,3]-mean(Y[,3])),ncol=3)#
#
sigma<-t(E)%*%E/Q#
lnlike<--Q*(P/2)*log(2*pi)-(Q/2)*log(det(sigma))-Q*P/2#
#
#calculate total r2#
varMatrix<-t(varY)%*%varY/Q#
R2<-1-diag(sigma)/diag(varMatrix)
R2
lnlike
#calculate r^2 based on dY's#
varDY=(Y-X)[-1,]#
DYhat=c()#
for(i in 2:nrow(predict)){#
	x=predict[i,]-predict[i-1,]#
	DYhat=rbind(DYhat,x)#
}#
#
E_D<-DYhat-varDY#
#
QD<-nrow(Y)#
varMatrix_D<-t(varDY)%*%varDY/Q#
R2_D<-diag(sigma)/diag(varMatrix_D)
R2_D
diag(varMatrix)
1-diag(sigma)
R2<-(1-diag(sigma))/diag(varMatrix)
R2
R2<-1-diag(sigma)/diag(varMatrix)
R2
Z%*%D
E
sd(E)
head(Y)
t(E)%*%E/Q
R2
R2_D
prod
prod$uniqueID<-paste(prod$lakeID,prod$year,sep='.')
uniques<-unique(prod$uniqueID)
uniques
percent.prod<-c()#
for(i in 1:length(uniques)){#
	lakei<-prod[prod$uniqueID==uniques[i],]#
	tot<-sum(lakei$production.g.m2.yr)#
	for(j in 1:nrow(lakei)){#
		x[j]<-lakei$production.g.m2.yr[j]/tot#
	}#
	percent.prod<-c(percent.prod,x)#
}
percent.prod
length(percent.prod)
nrow(prod)
i=1
lakei<-prod[prod$uniqueID==uniques[i],]
lakei
tot<-sum(lakei$production.g.m2.yr)
tot
for(j in 1:nrow(lakei)){#
		x[j]<-lakei$production.g.m2.yr[j]/tot#
	}
x
percent.prod<-c()#
for(i in 1:length(uniques)){#
	lakei<-prod[prod$uniqueID==uniques[i],]#
	tot<-sum(lakei$production.g.m2.yr)#
	x<-c()#
	for(j in 1:nrow(lakei)){#
		x[j]<-lakei$production.g.m2.yr[j]/tot#
	}#
	percent.prod<-c(percent.prod,x)#
}
percent.prod
length(percent.prod)
prod$percent.prod<-percent.prod
ggplot(aes(x=prod$year[prod$taxa=='cyclopoid'],y=prod$percent.prod[prod$taxa=='cyclopoid'],fill=prod$lakeID[prod$taxa=='cyclopoid']))+geom_bar(stat='identity')+scale_fill_manual(values=c('EL'='blue','WL'='brown'))
prod$year[prod$taxa=='cyclopoid']
prod$percent.prod[prod$taxa=='cyclopoid']
ggplot(aes(x=prod$year[prod$taxa=='cyclopoid'],y=prod$percent.prod[prod$taxa=='cyclopoid']))+geom_bar(stat='identity')+scale_fill_manual(values=c('EL'='blue','WL'='brown'))
prod$percent.prod[prod$taxa=='cyclopoid']
ggplot(data=prod,aes(x=prod$year[prod$taxa=='cyclopoid'],y=prod$percent.prod[prod$taxa=='cyclopoid'],fill=prod$lakeID[prod$taxa=='cyclopoid']))+geom_bar(stat='identity')+scale_fill_manual(values=c('EL'='blue','WL'='brown'))
cyclopoid.data<-prod[prod$taxa=='cyclopoid',]
ggplot(data=cyclopoid.data,aes(x=year,y=percent.prod,fill=lakeID))+geom_bar(stat='identity')+scale_fill_manual(values=c('EL'='blue','WL'='brown'))
ggplot(data=cyclopoid.data,aes(x=year,y=percent.prod,fill=lakeID))+geom_bar(stat='identity',position=position_dodge())+scale_fill_manual(values=c('EL'='blue','WL'='brown'))
ggplot(data=cyclopoid.data,aes(x=year,y=percent.prod,fill=lakeID))+geom_bar(stat='identity',position=position_dodge())+scale_fill_manual(values=c('EL'='blue','WL'='brown'))
D
round(D,4)
head(z.X)
head(z.Mat)
head(z.covMat)
head(tsMat)
head(tot.data)
tsMat<-as.matrix(tot.data[,6:8],ncol=3)
head(tot.data)
tsMat<-as.matrix(tot.data[,c(6:8,14)],ncol=4)
tsMat
X=tsMat[1:nrow(tsMat)-1,] # this is Xt
Y=tsMat[2:nrow(tsMat),] #this is Xt+1
covMat<-as.matrix(tot.data[,9:13],ncol=5)
covMat<-covMat[1:nrow(covMat)-1,]
head(X)
head(covMat)
#remove transition year data points in both X, Y, and covariate data#
WLyearX<-tot.data$year[tot.data$lakeID=='WL'][1:length(tot.data$year[tot.data$lakeID=='WL'])-1]#
WLyearY<-tot.data$year[tot.data$lakeID=='WL'][2:length(tot.data$year[tot.data$lakeID=='WL'])]#
#
X<-X[WLyearX==WLyearY,]#
Y<-Y[WLyearX==WLyearY,]#
covMat<-covMat[WLyearX==WLyearY,]
col.mean<-colMeans(covMat) #get means for columns#
col.sd<-apply(covMat,2,sd)#
#
z.covMat<-c()#
for(i in 1:nrow(covMat)){#
	x<-(covMat[i,]-col.mean)/col.sd#
	z.covMat<-rbind(z.covMat,x)#
}
#z-score X and Y#
col.mean<-colMeans(X)#
col.sd<-apply(X,2,sd)#
#
z.X<-c()#
for(i in 1:nrow(X)){#
	x<-(X[i,]-col.mean)/col.sd#
	z.X<-rbind(z.X,x)#
}#
#
col.mean<-colMeans(Y)#
col.sd<-apply(Y,2,sd)#
#
z.Y<-c()#
for(i in 1:nrow(X)){#
	x<-(Y[i,]-col.mean)/col.sd#
	z.Y<-rbind(z.Y,x)#
}#
#
one<-rep(1,nrow(X)) #1 in the model
head(z.X)
head(z.Y)
Z<-cbind(one,z.X,z.covMat) #combining 1, X, u <---can change z.covMat to covMat if you don't want z-scored covariate matrix
D<-solve(t(Z)%*%Z)%*%t(Z)%*%z.Y
D
ound(D,4)
ound(D,4)
round(D,4)
predict<-Z%*%D
Q<-nrow(X)#
P<-ncol(X)#
R<-ncol(z.covMat)#
E<-predict-z.Y#
rmse<-sd(E)#
varY=matrix(c(z.Y[,1]-mean(z.Y[,1]),z.Y[,2]-mean(z.Y[,2]),z.Y[,3]-mean(z.Y[,3])),ncol=4)#
#
sigma<-t(E)%*%E/Q#
lnlike<--Q*(P/2)*log(2*pi)-(Q/2)*log(det(sigma))-Q*P/2#
#
#calculate total r2#
varMatrix<-t(varY)%*%varY/Q#
R2<-1-diag(sigma)/diag(varMatrix)
R2
diag(sigma)
diag(varMatrix)
R2<-(1-diag(sigma))/diag(varMatrix)
R2
varDY=(z.Y-z.X)[-1,]#
DYhat=c()#
for(i in 2:nrow(predict)){#
	x=predict[i,]-predict[i-1,]#
	DYhat=rbind(DYhat,x)#
}#
#
E_D<-DYhat-varDY#
#
QD<-nrow(z.Y)#
varMatrix_D<-t(varDY)%*%varDY/Q#
R2_D<-diag(sigma)/diag(varMatrix_D)
R2_D
head(tot.data)
tot.data<-tot.data[tot.data$lakeID=='EL',]
tsMat<-as.matrix(tot.data[,c(6:8,14)],ncol=4)
head(tsMat)
X=tsMat[1:nrow(tsMat)-1,] # this is Xt#
Y=tsMat[2:nrow(tsMat),] #this is Xt+1
covMat<-as.matrix(tot.data[,9:13],ncol=5)#
covMat<-covMat[1:nrow(covMat)-1,]
nrow(X)
nrow(covMat)
ELyearX<-tot.data$year[tot.data$lakeID=='EL'][1:length(tot.data$year[tot.data$lakeID=='EL'])-1]#
ELyearY<-tot.data$year[tot.data$lakeID=='EL'][2:length(tot.data$year[tot.data$lakeID=='EL'])]#
#
X<-X[ELyearX==ELyearY,]#
Y<-Y[ELyearX==ELyearY,]#
covMat<-covMat[ELyearX==ELyearY,]
#make z-scored matrix to find effect sizes#
col.mean<-colMeans(covMat) #get means for columns#
col.sd<-apply(covMat,2,sd)#
#
z.covMat<-c()#
for(i in 1:nrow(covMat)){#
	x<-(covMat[i,]-col.mean)/col.sd#
	z.covMat<-rbind(z.covMat,x)#
}#
#
#z-score X and Y#
col.mean<-colMeans(X)#
col.sd<-apply(X,2,sd)#
#
z.X<-c()#
for(i in 1:nrow(X)){#
	x<-(X[i,]-col.mean)/col.sd#
	z.X<-rbind(z.X,x)#
}#
#
col.mean<-colMeans(Y)#
col.sd<-apply(Y,2,sd)#
#
z.Y<-c()#
for(i in 1:nrow(X)){#
	x<-(Y[i,]-col.mean)/col.sd#
	z.Y<-rbind(z.Y,x)#
}#
#
one<-rep(1,nrow(X)) #1 in the model#
#
Z<-cbind(one,z.X,z.covMat) #combining 1, X, u <---can change z.covMat to covMat if you don't want z-scored covariate matrix#
#
#estimate parameters using CLS#
D<-solve(t(Z)%*%Z)%*%t(Z)%*%z.Y
D
round(D,4)
weekNum<-as.numeric(format(as.Date(tot.data,'%m/%d/%Y')+3),'%U')
head(tot.data)
weekNum<-as.numeric(format(as.Date(tot.data$dateSample,'%Y-%m-%d')+3),'%U')
weekNum
dt<-as.Date(tot.data$dateSample,'%Y-%m-%d')
dt
as.numeric((format(dt+3,'%U')))
ggplot(data=cyclopoid.data,aes(x=year,y=percent.prod,fill=lakeID))+geom_bar(stat='identity',position=position_dodge())+scale_fill_manual(values=c('EL'='blue','WL'='brown'))
head(prod)
daphnia.data<-prod[prod$taxa=='daphnia',]
ggplot(data=daphnia.data, aes(x=year,y=percent.prod,fill=lakeID))+geom_bar(stat='identity',position=position_dodge())+scale_fill_manual(values=c('EL'='blue','WL'='brown'))
holopedium.data<-prod[prod$taxa=='holopedium',]
ggplot(data=holopedium.data, aes(x=year,y=percent.prod,fill=lakeID))+geom_bar(stat='identity',position=position_dodge())+scale_fill_manual(values=c('EL'='blue','WL'='brown'))
el.data<-prod[prod$lakeID=='EL',]
ggplot(data=el.data, aes(x=year,y=percent.prod,fill=taxa))+geom_bar(stat='identity')
prod
plot(as.Date(prod$year[prod$lakeID=='EL' & prod$taxa=='cyclopoid'],'%Y'),prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='cyclopoid'])
as.Date(prod$year[prod$lakeID=='EL' & prod$taxa=='cyclopoid'],'%Y')
prod$year[prod$lakeID=='EL' & prod$taxa=='cyclopoid']
plot(prod$year[prod$lakeID=='EL' & prod$taxa=='cyclopoid'],prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='cyclopoid'])
plot(prod$year[prod$lakeID=='EL' & prod$taxa=='cyclopoid'],prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='cyclopoid'])#
points(prod$year[prod$lakeID=='WL' & prod$taxa=='cyclopoid'],prod$percent.prod[prod$lakeID=='WL' & prod$taxa=='cyclopoid'],pch=19)
prod$year[prod$lakeID=='WL' & prod$taxa=='cyclopoid']
prod$percent.prod[prod$lakeID=='WL' & prod$taxa=='cyclopoid']
plot(prod$year[prod$lakeID=='EL' & prod$taxa=='cyclopoid'],prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='cyclopoid'],ylim=c(0,1))#
points(prod$year[prod$lakeID=='WL' & prod$taxa=='cyclopoid'],prod$percent.prod[prod$lakeID=='WL' & prod$taxa=='cyclopoid'],pch=19)
as.Date(prod$year,'%Y')
as.Date(as.character(prod$year),'%Y')
format(as.Date(as.character(prod$year),'%Y'),'%Y')
plot(format(as.Date(as.character(prod$year[prod$lakeID=='EL' & prod$taxa=='cyclopoid']),'%Y'),'%Y'),prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='cyclopoid'],ylim=c(0,1))
plot(format(as.Date(as.character(prod$year[prod$lakeID=='EL' & prod$taxa=='cyclopoid']),'%Y'),'%Y'),prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='cyclopoid'],ylim=c(0,1),pch=19,cex=1.3,col='brown')
points(format(as.Date(as.character(prod$year[prod$lakeID=='WL' & prod$taxa=='cyclopoid']),'%Y'),'%Y'),prod$percent.prod[prod$lakeID=='WL' & prod$taxa=='cyclopoid'],ylim=c(0,1),pch=19,cex=1.3,col='blue')
points(format(as.Date(as.character(prod$year[prod$lakeID=='EL' & prod$taxa=='daphnia']),'%Y'),'%Y'),prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='daphnia'],ylim=c(0,1),pch=15,cex=1.3,col='brown')
jitter(points(format(as.Date(as.character(prod$year[prod$lakeID=='EL' & prod$taxa=='daphnia']),'%Y'),'%Y'),prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='daphnia'],ylim=c(0,1),pch=15,cex=1.3,col='brown'))
plot(format(as.Date(as.character(prod$year[prod$lakeID=='EL' & prod$taxa=='cyclopoid']),'%Y'),'%Y'),prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='cyclopoid'],ylim=c(0,1),pch=19,cex=1.3,col='brown')#
points(format(as.Date(as.character(prod$year[prod$lakeID=='WL' & prod$taxa=='cyclopoid']),'%Y'),'%Y'),prod$percent.prod[prod$lakeID=='WL' & prod$taxa=='cyclopoid'],ylim=c(0,1),pch=19,cex=1.3,col='blue')#
jitter(points(format(as.Date(as.character(prod$year[prod$lakeID=='EL' & prod$taxa=='daphnia']),'%Y'),'%Y'),prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='daphnia'],ylim=c(0,1),pch=15,cex=1.3,col='brown'))
jitter(format(as.Date(as.character(prod$year[prod$lakeID=='EL' & prod$taxa=='daphnia']),'%Y'),'%Y'))
plot(format(prod$year[prod$lakeID=='EL' & prod$taxa=='cyclopoid'],prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='cyclopoid'],ylim=c(0,1),pch=19,cex=1.3,col='brown')
plot(prod$year[prod$lakeID=='EL' & prod$taxa=='cyclopoid'],prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='cyclopoid'],ylim=c(0,1),pch=19,cex=1.3,col='brown')
plot(prod$year[prod$lakeID=='EL' & prod$taxa=='cyclopoid'],prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='cyclopoid'],ylim=c(0,1),pch=19,cex=1.3,col='brown')
points(prod$year[prod$lakeID=='WL' & prod$taxa=='cyclopoid'],'%Y'),'%Y'),prod$percent.prod[prod$lakeID=='WL' & prod$taxa=='cyclopoid'],ylim=c(0,1),pch=19,cex=1.3,col='blue')
points(prod$year[prod$lakeID=='WL' & prod$taxa=='cyclopoid'],prod$percent.prod[prod$lakeID=='WL' & prod$taxa=='cyclopoid'],ylim=c(0,1),pch=19,cex=1.3,col='blue')
points(jitter(prod$year[prod$lakeID=='EL' & prod$taxa=='daphnia']),prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='daphnia'],ylim=c(0,1),pch=15,cex=1.3,col='brown'))
points(jitter(prod$year[prod$lakeID=='EL' & prod$taxa=='daphnia']),prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='daphnia'],ylim=c(0,1),pch=15,cex=1.3,col='brown')
points(prod$year[prod$lakeID=='WL' & prod$taxa=='daphnia'],prod$percent.prod[prod$lakeID=='WL' & prod$taxa=='daphnia'],ylim=c(0,1),pch=15,cex=1.3,col='blue')
points(prod$year[prod$lakeID=='EL' & prod$taxa=='holopedium']),prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='holopedium'],ylim=c(0,1),pch=16,cex=1.3,col='brown')
points(prod$year[prod$lakeID=='EL' & prod$taxa=='holopedium'],prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='holopedium'],ylim=c(0,1),pch=16,cex=1.3,col='brown')
points(prod$year[prod$lakeID=='WL' & prod$taxa=='holopedium'],prod$percent.prod[prod$lakeID=='WL' & prod$taxa=='holopedium'],ylim=c(0,1),pch=16,cex=1.3,col='blue')
plot(prod$year[prod$lakeID=='EL' & prod$taxa=='cyclopoid'],prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='cyclopoid'],ylim=c(0,1),pch=19,cex=1.3,col='brown')#
points(prod$year[prod$lakeID=='WL' & prod$taxa=='cyclopoid'],prod$percent.prod[prod$lakeID=='WL' & prod$taxa=='cyclopoid'],ylim=c(0,1),pch=19,cex=1.3,col='blue')#
points(jitter(prod$year[prod$lakeID=='EL' & prod$taxa=='daphnia']),prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='daphnia'],ylim=c(0,1),pch=15,cex=1.3,col='brown')#
points(prod$year[prod$lakeID=='WL' & prod$taxa=='daphnia'],prod$percent.prod[prod$lakeID=='WL' & prod$taxa=='daphnia'],ylim=c(0,1),pch=15,cex=1.3,col='blue')#
points(prod$year[prod$lakeID=='EL' & prod$taxa=='holopedium'],prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='holopedium'],ylim=c(0,1),pch=17,cex=1.3,col='brown')#
points(prod$year[prod$lakeID=='WL' & prod$taxa=='holopedium'],prod$percent.prod[prod$lakeID=='WL' & prod$taxa=='holopedium'],ylim=c(0,1),pch=17,cex=1.3,col='blue')
plot(prod$year[prod$lakeID=='EL' & prod$taxa=='cyclopoid'],prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='cyclopoid'],ylim=c(0.1,0.6),pch=19,cex=1.3,col='brown')#
points(prod$year[prod$lakeID=='WL' & prod$taxa=='cyclopoid'],prod$percent.prod[prod$lakeID=='WL' & prod$taxa=='cyclopoid'],ylim=c(0,1),pch=19,cex=1.3,col='blue')#
points(jitter(prod$year[prod$lakeID=='EL' & prod$taxa=='daphnia']),prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='daphnia'],ylim=c(0,1),pch=15,cex=1.3,col='brown')#
points(prod$year[prod$lakeID=='WL' & prod$taxa=='daphnia'],prod$percent.prod[prod$lakeID=='WL' & prod$taxa=='daphnia'],ylim=c(0,1),pch=15,cex=1.3,col='blue')#
points(prod$year[prod$lakeID=='EL' & prod$taxa=='holopedium'],prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='holopedium'],ylim=c(0,1),pch=17,cex=1.3,col='brown')#
points(prod$year[prod$lakeID=='WL' & prod$taxa=='holopedium'],prod$percent.prod[prod$lakeID=='WL' & prod$taxa=='holopedium'],ylim=c(0,1),pch=17,cex=1.3,col='blue')
plot(prod$year[prod$lakeID=='EL' & prod$taxa=='cyclopoid'],prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='cyclopoid'],ylim=c(0.1,0.6),pch=19,cex=1.3,col='brown')#
points(prod$year[prod$lakeID=='WL' & prod$taxa=='cyclopoid'],prod$percent.prod[prod$lakeID=='WL' & prod$taxa=='cyclopoid'],ylim=c(0,1),pch=1,cex=1.3,col='blue')#
points(jitter(prod$year[prod$lakeID=='EL' & prod$taxa=='daphnia']),prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='daphnia'],ylim=c(0,1),pch=15,cex=1.3,col='brown')#
points(prod$year[prod$lakeID=='WL' & prod$taxa=='daphnia'],prod$percent.prod[prod$lakeID=='WL' & prod$taxa=='daphnia'],ylim=c(0,1),pch=0,cex=1.3,col='blue')#
points(prod$year[prod$lakeID=='EL' & prod$taxa=='holopedium'],prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='holopedium'],ylim=c(0,1),pch=17,cex=1.3,col='brown')#
points(prod$year[prod$lakeID=='WL' & prod$taxa=='holopedium'],prod$percent.prod[prod$lakeID=='WL' & prod$taxa=='holopedium'],ylim=c(0,1),pch=2,cex=1.3,col='blue')
axis(1,at=c(2011,2012,2013,2014))
plot(prod$year[prod$lakeID=='EL' & prod$taxa=='cyclopoid'],prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='cyclopoid'],ylim=c(0.1,0.6),pch=19,cex=1.3,col='brown',ylab='% production',xlab='year',xaxt='n')#
points(prod$year[prod$lakeID=='WL' & prod$taxa=='cyclopoid'],prod$percent.prod[prod$lakeID=='WL' & prod$taxa=='cyclopoid'],ylim=c(0,1),pch=1,cex=1.3,col='blue')#
points(jitter(prod$year[prod$lakeID=='EL' & prod$taxa=='daphnia']),prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='daphnia'],ylim=c(0,1),pch=15,cex=1.3,col='brown')#
points(prod$year[prod$lakeID=='WL' & prod$taxa=='daphnia'],prod$percent.prod[prod$lakeID=='WL' & prod$taxa=='daphnia'],ylim=c(0,1),pch=0,cex=1.3,col='blue')#
points(prod$year[prod$lakeID=='EL' & prod$taxa=='holopedium'],prod$percent.prod[prod$lakeID=='EL' & prod$taxa=='holopedium'],ylim=c(0,1),pch=17,cex=1.3,col='brown')#
points(prod$year[prod$lakeID=='WL' & prod$taxa=='holopedium'],prod$percent.prod[prod$lakeID=='WL' & prod$taxa=='holopedium'],ylim=c(0,1),pch=2,cex=1.3,col='blue')#
axis(1,at=c(2011,2012,2013,2014))
head(zoops)
test<-rowSums(zoops[,6:8])
head(test)
zoops$totalBiomass<-rowSums(zoops[,6:8])
head(zoops)
zoops$year<-format(as.Date(zoops$dateSample,'%Y-%m-%d'),'%Y')
head(zoops)
boxplot(zoops$totalBiomass~zoops$lakeID*zoops$year)
boxplot(zoops$totalBiomass~zoops$lakeID*zoops$year,col=rep(c('blue','brown'),4))
boxplot(zoops$totalBiomass~zoops$lakeID*zoops$year,col=rep(c('brown','blue'),4))
chaobs
setwd('~/Documents/Notre Dame//long lake data')
list.files()
setwd('~/Documents/Notre Dame//long lake data/FINAL_data')
list.files()
setwd('~/Documents/Notre Dame//long lake data/Chaoborus data')
list.files()
chaobs<-read.csv('chaoborusDataLongLake2011-2014.csv')
head(chaobs)
chaobs$year<-format(as.Date(chaobs$dateSample,'%m/%d/%y'),'%Y')
head(chaobs)
boxplot(chaobs$g.m2~chaobs$lakeID*chaobs$year)
boxplot(chaobs$g.m2~chaobs$lakeID*chaobs$year,col=rep(c('brown','blue'),4))
head(zoops)
#load zooplankton data#
setwd('~/Documents/Notre Dame/long lake data/MAR data')#
#
zoops<-read.csv('zoopDataMatrix2011-2014.csv')#
#
#load covariate data#
cov.mat<-read.csv('covariateData2011-2014.csv')#
#
#combine the two to sort#
tot.data<-cbind(zoops,cov.mat[2:ncol(cov.mat)])#
#
#sort by date#
tot.data<-tot.data[order(tot.data$lakeID,tot.data$dateSample),]#
#make lake-year ID#
tot.data$year<-format(as.Date(tot.data$dateSample,'%Y-%m-%d'),'%Y')#
tot.data$lake.year<-paste(tot.data$lakeID,format(as.Date(tot.data$dateSample,'%Y-%m-%d'),'%Y'),sep='.')#
lake.year<-c(tot.data$lake.year[tot.data$lakeID=='EL'],tot.data$lake.year[tot.data$lakeID=='WL'])#
#
#remove NAs#
tot.data<-tot.data[!is.na(tot.data$cyclopoid.gm2),]#
tot.data<-tot.data[!is.na(tot.data$holhopedium.gm2),]#
#
#build a matrix of data with 3 taxa#
tsMat<-as.matrix(tot.data[,6:8],ncol=3)#
#
#make X and Y#
X=tsMat[1:nrow(tsMat)-1,] # this is Xt#
Y=tsMat[2:nrow(tsMat),] #this is Xt+1#
#
#make covariate matrix#
covMat<-as.matrix(tot.data[,9:14],ncol=6)#
covMat<-covMat[1:nrow(covMat)-1,]#
#
#remove transition year data points in both X, Y, and covariate data#
WLyearX<-tot.data$year[tot.data$lakeID=='WL'][1:length(tot.data$year[tot.data$lakeID=='WL'])-1]#
WLyearY<-tot.data$year[tot.data$lakeID=='WL'][2:length(tot.data$year[tot.data$lakeID=='WL'])]#
#
X<-X[WLyearX==WLyearY,]#
Y<-Y[WLyearX==WLyearY,]#
covMat<-covMat[WLyearX==WLyearY,]#
#
#make z-scored matrix to find effect sizes#
col.mean<-colMeans(covMat) #get means for columns#
col.sd<-apply(covMat,2,sd)#
#
z.covMat<-c()#
for(i in 1:nrow(covMat)){#
	x<-(covMat[i,]-col.mean)/col.sd#
	z.covMat<-rbind(z.covMat,x)#
}#
#
#z-score X and Y#
col.mean<-colMeans(X)#
col.sd<-apply(X,2,sd)#
#
z.X<-c()#
for(i in 1:nrow(X)){#
	x<-(X[i,]-col.mean)/col.sd#
	z.X<-rbind(z.X,x)#
}#
#
col.mean<-colMeans(Y)#
col.sd<-apply(Y,2,sd)#
#
z.Y<-c()#
for(i in 1:nrow(X)){#
	x<-(Y[i,]-col.mean)/col.sd#
	z.Y<-rbind(z.Y,x)#
}#
#
one<-rep(1,nrow(X)) #1 in the model#
#
Z<-cbind(one,z.X,z.covMat) #combining 1, X, u <---can change z.covMat to covMat if you don't want z-scored covariate matrix#
#
#estimate parameters using CLS#
D<-solve(t(Z)%*%Z)%*%t(Z)%*%z.Y#
#
#calculate predicted #
predict<-Z%*%D#
#Q=length of time series#
#P=number of species#
#R=number of coviates#
#E=errors (predict-X)#
#varY=variance in Y=obs-mean#
#root mean squared error sd(E)#
#
Q<-nrow(X)#
P<-ncol(X)#
R<-ncol(z.covMat)#
E<-predict-Y#
rmse<-sd(E)#
varY=matrix(c(Y[,1]-mean(Y[,1]),Y[,2]-mean(Y[,2]),Y[,3]-mean(Y[,3])),ncol=3)#
#
sigma<-t(E)%*%E/Q#
lnlike<--Q*(P/2)*log(2*pi)-(Q/2)*log(det(sigma))-Q*P/2#
#
#calculate total r2#
varMatrix<-t(varY)%*%varY/Q#
R2<-1-diag(sigma)/diag(varMatrix)#
#
#calculate r^2 based on dY's#
varDY=(Y-X)[-1,]#
DYhat=c()#
for(i in 2:nrow(predict)){#
	x=predict[i,]-predict[i-1,]#
	DYhat=rbind(DYhat,x)#
}#
#
E_D<-DYhat-varDY#
#
QD<-nrow(Y)#
varMatrix_D<-t(varDY)%*%varDY/Q#
R2_D<-diag(sigma)/diag(varMatrix_D)
D
round(D,4)
round.D<-round(D,4)
write.csv(round.D,'MARcoefficients_EL&WL.csv')
R2
predict<-Z%*%D#
#Q=length of time series#
#P=number of species#
#R=number of coviates#
#E=errors (predict-X)#
#varY=variance in Y=obs-mean#
#root mean squared error sd(E)#
#
Q<-nrow(X)#
P<-ncol(X)#
R<-ncol(z.covMat)#
E<-predict-z.Y#
rmse<-sd(E)#
varY=matrix(c(z.Y[,1]-mean(z.Y[,1]),z.Y[,2]-mean(z.Y[,2]),z.Y[,3]-mean(z.Y[,3])),ncol=3)#
#
sigma<-t(E)%*%E/Q#
lnlike<--Q*(P/2)*log(2*pi)-(Q/2)*log(det(sigma))-Q*P/2#
#
#calculate total r2#
varMatrix<-t(varY)%*%varY/Q#
R2<-1-diag(sigma)/diag(varMatrix)
D
R2
varDY=(z.Y-z.X)[-1,]#
DYhat=c()#
for(i in 2:nrow(predict)){#
	x=predict[i,]-predict[i-1,]#
	DYhat=rbind(DYhat,x)#
}#
#
E_D<-DYhat-varDY#
#
QD<-nrow(Y)#
varMatrix_D<-t(varDY)%*%varDY/Q#
R2_D<-diag(sigma)/diag(varMatrix_D)
R2_D
tsMat<-as.matrix(tot.data[,c(6:8,14)],ncol=4)#
#
#make X and Y#
X=tsMat[1:nrow(tsMat)-1,] # this is Xt#
Y=tsMat[2:nrow(tsMat),] #this is Xt+1#
#
#make covariate matrix#
covMat<-as.matrix(tot.data[,9:13],ncol=5)#
covMat<-covMat[1:nrow(covMat)-1,]#
#
#remove transition year data points in both X, Y, and covariate data#
WLyearX<-tot.data$year[tot.data$lakeID=='WL'][1:length(tot.data$year[tot.data$lakeID=='WL'])-1]#
WLyearY<-tot.data$year[tot.data$lakeID=='WL'][2:length(tot.data$year[tot.data$lakeID=='WL'])]#
#
X<-X[WLyearX==WLyearY,]#
Y<-Y[WLyearX==WLyearY,]#
covMat<-covMat[WLyearX==WLyearY,]#
#
#make z-scored matrix to find effect sizes#
col.mean<-colMeans(covMat) #get means for columns#
col.sd<-apply(covMat,2,sd)#
#
z.covMat<-c()#
for(i in 1:nrow(covMat)){#
	x<-(covMat[i,]-col.mean)/col.sd#
	z.covMat<-rbind(z.covMat,x)#
}#
#
#z-score X and Y#
col.mean<-colMeans(X)#
col.sd<-apply(X,2,sd)#
#
z.X<-c()#
for(i in 1:nrow(X)){#
	x<-(X[i,]-col.mean)/col.sd#
	z.X<-rbind(z.X,x)#
}#
#
col.mean<-colMeans(Y)#
col.sd<-apply(Y,2,sd)#
#
z.Y<-c()#
for(i in 1:nrow(X)){#
	x<-(Y[i,]-col.mean)/col.sd#
	z.Y<-rbind(z.Y,x)#
}#
#
one<-rep(1,nrow(X)) #1 in the model#
#
Z<-cbind(one,z.X,z.covMat) #combining 1, X, u <---can change z.covMat to covMat if you don't want z-scored covariate matrix#
#
#estimate parameters using CLS#
D<-solve(t(Z)%*%Z)%*%t(Z)%*%z.Y
D
round.D<-round(D,4)
write.csv(round.D,'MARcoeffs_chaobsTaxa.csv')
tot.data<-tot.data[tot.data$lakeID=='EL',]#
#
tsMat<-as.matrix(tot.data[,c(6:8,14)],ncol=4)#
#
#make X and Y#
X=tsMat[1:nrow(tsMat)-1,] # this is Xt#
Y=tsMat[2:nrow(tsMat),] #this is Xt+1#
#
#make covariate matrix#
covMat<-as.matrix(tot.data[,9:13],ncol=5)#
covMat<-covMat[1:nrow(covMat)-1,]#
#
#remove transition year data points in both X, Y, and covariate data#
ELyearX<-tot.data$year[tot.data$lakeID=='EL'][1:length(tot.data$year[tot.data$lakeID=='EL'])-1]#
ELyearY<-tot.data$year[tot.data$lakeID=='EL'][2:length(tot.data$year[tot.data$lakeID=='EL'])]#
#
X<-X[ELyearX==ELyearY,]#
Y<-Y[ELyearX==ELyearY,]#
covMat<-covMat[ELyearX==ELyearY,]#
#
#make z-scored matrix to find effect sizes#
col.mean<-colMeans(covMat) #get means for columns#
col.sd<-apply(covMat,2,sd)#
#
z.covMat<-c()#
for(i in 1:nrow(covMat)){#
	x<-(covMat[i,]-col.mean)/col.sd#
	z.covMat<-rbind(z.covMat,x)#
}#
#
#z-score X and Y#
col.mean<-colMeans(X)#
col.sd<-apply(X,2,sd)#
#
z.X<-c()#
for(i in 1:nrow(X)){#
	x<-(X[i,]-col.mean)/col.sd#
	z.X<-rbind(z.X,x)#
}#
#
col.mean<-colMeans(Y)#
col.sd<-apply(Y,2,sd)#
#
z.Y<-c()#
for(i in 1:nrow(X)){#
	x<-(Y[i,]-col.mean)/col.sd#
	z.Y<-rbind(z.Y,x)#
}#
#
one<-rep(1,nrow(X)) #1 in the model#
#
Z<-cbind(one,z.X,z.covMat) #combining 1, X, u <---can change z.covMat to covMat if you don't want z-scored covariate matrix#
#
#estimate parameters using CLS#
D<-solve(t(Z)%*%Z)%*%t(Z)%*%z.Y
round.D<-round(D,4)
write.csv(round.D,'MARcoeffs_ELonly.csv')
head(tot.data)
boxplot(tot.data$DOC~tot.data$lakeID*tot.data$year)
#load zooplankton data#
setwd('~/Documents/Notre Dame/long lake data/MAR data')#
#
zoops<-read.csv('zoopDataMatrix2011-2014.csv')#
#
#load covariate data#
cov.mat<-read.csv('covariateData2011-2014.csv')#
#
#combine the two to sort#
tot.data<-cbind(zoops,cov.mat[2:ncol(cov.mat)])
boxplot(tot.data$DOC~tot.data$lakeID*tot.data$year)
tot.data$year<-format(as.Date(tot.data$dateSample,'%Y-%m-%d'),'%Y')
boxplot(tot.data$DOC~tot.data$lakeID*tot.data$year)
boxplot(tot.data$DOC~tot.data$lakeID*tot.data$year,col=rep(c('brown','blue'),4))
boxplot(tot.data$temp~tot.data$lakeID*tot.data$year,col=rep(c('brown','blue'),4))
boxplot(tot.data$TP~tot.data$lakeID*tot.data$year,col=rep(c('brown','blue'),4))
boxplot(tot.data$chl~tot.data$lakeID*tot.data$year,col=rep(c('brown','blue'),4))
boxplot(tot.data$CP~tot.data$lakeID*tot.data$year,col=rep(c('brown','blue'),4))
boxplot(tot.data$CP~tot.data$lakeID*tot.data$year,col=rep(c('brown','blue'),4))
abline(h=250,col='red',lty=2,lwd=2)
28.45*12
2845*12
